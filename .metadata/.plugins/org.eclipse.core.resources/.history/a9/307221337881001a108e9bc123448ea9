package pkg;

import java.util.List;
import java.util.Map;

import util.Adjacent;
import util.Coord;

public class PathFinder {

	Map<Integer, Coord<?, ?>> cityCoordMap;
	Map<Integer, List<Adjacent<?, ?>>> weightedAdjMap;
	Map<Integer, Float> heurysticMap;

	PathFinder(Map<Integer, Coord<?, ?>> cityCoordMap, Map<Integer, List<Adjacent<?, ?>>> weightedAdjMap) {
		this.cityCoordMap = cityCoordMap;
		this.weightedAdjMap = weightedAdjMap;
	}

	public List<?> findPath(int start, int goal){
		this.heurysticMap = Calcul.makeHeuristic(cityCoordMap, goal);
		List<?> myPath=A_Star(start, goal);
		
		return myPath;
	} // public List<?> findPath(int start, int goal)

	private List<?> reconstruct_path(int cameFrom, int current){
		/*
	    total_path := {current}
	    while current in cameFrom.Keys:
	        current := cameFrom[current]
	        total_path.prepend(current)
	    return total_path
	    */
		return null;
	}
	
	/** 
	 * A* finds a path from start to goal.
	 * h is the heuristic function. h(n) estimates the cost to reach goal from node n.
	 * @param start
	 * @param goal
	 * @return
	 */
	private List<?> A_Star(int start, int goal){
		/*
	    // The set of discovered nodes that may need to be (re-)expanded.
	    // Initially, only the start node is known.
	    // This is usually implemented as a min-heap or priority queue rather than a hash-set.
	    openSet := {start}
	
	    // For node n, cameFrom[n] is the node immediately preceding it on the cheapest path from start
	    // to n currently known.
	    cameFrom := an empty map
	
	    // For node n, gScore[n] is the cost of the cheapest path from start to n currently known.
	    gScore := map with default value of Infinity
	    gScore[start] := 0
	
	    // For node n, fScore[n] := gScore[n] + h(n). fScore[n] represents our current best guess as to
	    // how short a path from start to finish can be if it goes through n.
	    fScore := map with default value of Infinity
	    fScore[start] := h(start)
	
	    while openSet is not empty
	        // This operation can occur in O(1) time if openSet is a min-heap or a priority queue
	        current := the node in openSet having the lowest fScore[] value
	        if current = goal
	            return reconstruct_path(cameFrom, current)
	
	        openSet.Remove(current)
	        for each neighbor of current
	            // d(current,neighbor) is the weight of the edge from current to neighbor
	            // tentative_gScore is the distance from start to the neighbor through current
	            tentative_gScore := gScore[current] + d(current, neighbor)
	            if tentative_gScore < gScore[neighbor]
	                // This path to neighbor is better than any previous one. Record it!
	                cameFrom[neighbor] := current
	                gScore[neighbor] := tentative_gScore
	                fScore[neighbor] := gScore[neighbor] + h(neighbor)
	                if neighbor not in openSet
	                    openSet.add(neighbor)
	
	    // Open set is empty but goal was never reached
	    return failure
	    */
		return null;
	}
}
