package obj;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Map;

import pkg.PathFinder;

public class Path {

	private List<Integer> path;
	private float cost;
	private float heuristc;
	private PathFinder pFinder;

	public Path(int start, PathFinder pFinder) {
		path = new ArrayList<Integer>(Arrays.asList(start));
		cost = 0;
		heuristc = 0;
		this.pFinder=pFinder;
		System.out.print(Arrays.asList(path));
	}
	
	public Path(Path oldPath, PathFinder pFinder){
		Collections.copy(path, oldPath.getPath());
		setPathHeuristic(); //no need to setCost cause setHeuristic do it
		this.pFinder=pFinder;
	}
	
	
	public float getCost() {
		return cost;
	}
	private void setCost() {
		float totalCost =0;
		int s;
		int e;
		float cost;
		for (int i=0; i<path.size()-2; i++) {
			s = path.get(i);
			e= path.get(i+1);
			cost=getEdgeCost(s, e);
			totalCost+=cost;
		}
		//TODO some up all path cost
		this.cost = totalCost;
	}
	
	public float getEdgeCost(int start, int end) {
		Map<Integer, List<Adjacent<?, ?>>> weightedAdjMap = pFinder.getWeightedAdjMap();
		List<Adjacent<?, ?>> adjList = weightedAdjMap.get(start);
		float weight=0;
		for (Adjacent<?, ?> a : adjList) {
			if(a.getCity()==end) {
				weight=a.getWeight();
			}
		}
		return weight;
	}
	
	public float getPathHeuristic() {
		return heuristc;
	}
	private void setPathHeuristic() {
		setCost();
		float h=this.cost;
		int lastPathNode = path.get(path.size()-1);
		h+=pFinder.getNodeHeurystic(lastPathNode);
		//TODO add heuristic of last node
		this.heuristc = h;
	}

	public List<Integer> getPath() {
		return path;
	}
	
	public boolean isSolusion() {
		int lastPathNode = path.get(path.size()-1);
		int sol = pFinder.getgoal();
		return lastPathNode==sol;
	}
	
	/**
	 * @param path
	 * @return if the path is valid, meaning are all edges taken existing
	 */
	public boolean isPathValid() {
		return true;
	} // public boolean isPathValid(List<?> path)

}
