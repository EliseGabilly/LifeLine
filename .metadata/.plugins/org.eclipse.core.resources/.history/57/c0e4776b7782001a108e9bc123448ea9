package pkg;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import obj.Adjacent;
import obj.Coord;
import util.Printer;

public class PathOptimizer {

	public PathOptimizer(Map<Integer, Coord<?, ?>> cityCoordMap, Map<Integer, List<Adjacent<?, ?>>> weightedAdjMap,
			List<Integer> nodeRequired) {
		
		List<Integer> subPath; // path between two needed cities
		List<List<Integer>> thePath = new ArrayList<List<Integer>>(); // all of sub path

		// initialize the pathResum
		List<Integer> sortedNodeRequired = sortNeededCities(nodeRequired);
		
		// find path between each needed cities
		PathFinder myPathFinder = new PathFinder(cityCoordMap, weightedAdjMap);
		int start;
		int end;
		for (int i = 0; i < sortedNodeRequired.size(); i++) {
			start = sortedNodeRequired.get(i);
			end = sortedNodeRequired.get(i + 1);
			subPath = myPathFinder.findPathBetweenTwoNode(start, end);
			Printer.printPathData(subPath, myPathFinder);
			thePath.add(subPath);
		}

	}

	/**
	 * Choose the sorting method
	 * @param nodeRequired
	 * @return
	 */
	private List<Integer> sortNeededCities(List<Integer> nodeRequired) {
		List<Integer> sortedPath = new ArrayList<Integer>();
		if (nodeRequired.size() < 5) {
			sortedPath = sortFewNeededCities(nodeRequired);
		} else {
			sortManyNeededCities(nodeRequired);
		}
		return sortedPath;
	}

	/**
	 * Test all possible path and calculate their cost
	 * @param nodeRequired
	 * @return
	 */
	private List<Integer> sortFewNeededCities(List<Integer> nodeRequired) {
		return nodeRequired;
	}

	/**
	 * Approximate the shortest path
	 * @param nodeRequired
	 * @return
	 */
	private List<Integer> sortManyNeededCities(List<Integer> nodeRequired) {
		System.out.println("Not implamented yet : sortManyNeededCities ");
		return null;
	}

}
