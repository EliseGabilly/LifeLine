package pkg;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import obj.Adjacent;
import obj.Coord;
import util.Printer;

public class PathOptimizer {

	Map<Integer, Coord<?, ?>> cityCoordMap;
	Map<Integer, List<Adjacent<?, ?>>> weightedAdjMap;
	Map<Integer, List<Adjacent<?, ?>>> neededWeightedAdjMap= new HashMap<Integer, List<Adjacent<?,?>>>();
	List<List<Integer>> thePath = new ArrayList<List<Integer>>(); // all of sub path
	List<Integer> nodeRequired;

	public PathOptimizer(Map<Integer, Coord<?, ?>> cityCoordMap, Map<Integer, List<Adjacent<?, ?>>> weightedAdjMap) {
		this.cityCoordMap = cityCoordMap;
		this.weightedAdjMap = weightedAdjMap;
	}

	public List<Integer> findPath(List<Integer> nodeRequired, int mainCity) {
		System.out.println("main city : "+mainCity);
		System.out.println("node requierd : "+nodeRequired);
		List<Integer> subPath; // path between two needed cities
		
		// make neededWeightedAdjMap
		makeNeededWeightedAdjMap(nodeRequired, mainCity);
		// get the path to use with main city at the end and the beginning
		List<Integer> sortedNodeRequired = sortNeededCities(nodeRequired,mainCity);

		// find path between each needed cities
		PathFinder myPathFinder = new PathFinder(cityCoordMap, weightedAdjMap);
		int start;
		int end;
		for (int i = 0; i < sortedNodeRequired.size()-1; i++) {
			start = sortedNodeRequired.get(i);
			end = sortedNodeRequired.get(i + 1);
			subPath = myPathFinder.findPathBetweenTwoNode(start, end);
			Printer.printPathData(subPath, myPathFinder);
			thePath.add(subPath);
		}

		List<Integer> flatPath = flatenThePath(thePath);
		return flatPath;
	}
	
	

	private void makeNeededWeightedAdjMap(List<Integer> nodeRequired, int mainCity) {
		List<Integer> allNode = new ArrayList<Integer>(nodeRequired);
		allNode.add(mainCity);
		LinkedHashSet<Integer> hashSet = new LinkedHashSet<>(allNode);
		allNode = new ArrayList<>(hashSet);
		
		List<Adjacent<?, ?>> lAdj;
		Adjacent<?, ?> oneAdj;
		float weight;
		for(Integer oneNode : allNode) {
			lAdj = new ArrayList<Adjacent<?,?>>();
			for(Integer aNode : allNode) {
				weight = Calcul.getDistance(cityCoordMap.get(oneNode), cityCoordMap.get(aNode));
				oneAdj=new Adjacent<Integer, Integer>(aNode, weight);
				lAdj.add(oneAdj);
			}
			neededWeightedAdjMap.put(oneNode, lAdj);
		}
         
	}
	
	private List<Integer> flatenThePath(List<List<Integer>> thePath ){
		List<Integer> flatPath = new ArrayList<Integer>();
		flatPath.add(thePath.get(0).get(0));
		for(List<Integer> subPath : thePath) {
			flatPath.addAll(subPath.subList(1, subPath.size()));
		}
		return flatPath;
	}

	/**
	 * Choose the sorting method
	 * 
	 * @param nodeRequired
	 * @return
	 */
	private List<Integer> sortNeededCities(List<Integer> nodeRequired, int mainCity) {
		List<Integer> sortedPath = new ArrayList<Integer>();
		if (nodeRequired.size() < 5) {
			sortedPath = sortFewNeededCities(nodeRequired, mainCity);
		} else {
			sortManyNeededCities(nodeRequired);
		}
		return sortedPath;
	}

	/**
	 * Test all possible path and calculate their cost
	 * 
	 * @param nodeRequired
	 * @return
	 */
	private List<Integer> sortFewNeededCities(List<Integer> nodeRequired, int mainCity) {
		// get all path possible
		Set<List<Integer>> setPermutationPath = permute(nodeRequired);
		@SuppressWarnings("unchecked")
		List<Integer>[] permutationPath = (List<Integer>[]) setPermutationPath.toArray();
		// get the cheapest path
		List<Integer> cheapestPermutation = permutationPath[0];
		cheapestPermutation.add(mainCity);
		cheapestPermutation.add(0, mainCity); // add main city at the begining and the end
		float cheapestCost = Calcul.getCost(cheapestPermutation, neededWeightedAdjMap);
		
		List<Integer> testPermutation;
		float testCost;
		for(List<Integer> onePath : permutationPath) {
			testPermutation = onePath;
			testPermutation.add(mainCity);
			testPermutation.add(0, mainCity); // add main city at the begining and the end
			testCost = Calcul.getCost(testPermutation, neededWeightedAdjMap);
			System.out.println(Arrays.asList(testPermutation)+" for "+testCost);
			if(testCost<cheapestCost) {
				cheapestCost=testCost;
				cheapestPermutation=testPermutation;
			}
		}
		return cheapestPermutation;
	}
	public static Set<List<Integer>> permute(List<Integer> l) {
		Set<List<Integer>> res = new LinkedHashSet<>();
		if (l.isEmpty()) {
			res.add(l);
		} else {
			Set<List<Integer>> storePermute = new LinkedHashSet<>();
			List<Integer> subL;
			List<Integer> r;
			for (int i = 0; i < l.size(); i++) {

				subL =  l.subList(0, i);
				subL.addAll(l.subList(i + 1, l.size()-1));
				storePermute =  permute(subL);
				for (List<Integer> s : storePermute) {
					r=Arrays.asList(l.get(i));
					r.addAll(s);
					res.add(r);
				}
			}
		}
		return res;
	}

	/**
	 * Approximate the shortest path
	 * 
	 * @param nodeRequired
	 * @return
	 */
	private List<Integer> sortManyNeededCities(List<Integer> nodeRequired) {
		System.out.println("Not implamented yet : sortManyNeededCities ");
		return null;
	}

}
