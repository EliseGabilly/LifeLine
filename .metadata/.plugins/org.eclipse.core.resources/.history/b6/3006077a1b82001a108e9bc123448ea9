package obj;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Map;

import pkg.PathFinder;

public class Path {

	private List<Integer> path;
	private float cost;
	private float heuristc;
	private PathFinder pFinder;

	public Path(int start, PathFinder pFinder) {
		path = new ArrayList<Integer>(Arrays.asList(start));
		cost = 0;
		heuristc = 0;
		this.pFinder=pFinder;
	}
	
	public Path(Path oldPath, PathFinder pFinder){
		Collections.copy(path, oldPath.getPath());
		setHeuristic(); //no need to setCost cause setHeuristic do it
		this.pFinder=pFinder;
	}

	public float getCost() {
		return cost;
	}
	private void setCost() {
		float totalCost =0;
		int s;
		int e;
		float cost;
		for (int i=0; i<path.size()-2; i++) {
			s = path.get(i);
			e= path.get(i+1);
			cost
			
		}
		//TODO some up all path cost
		this.cost = c;
	}
	
	public float getEdgeCost(int start, int end) {
		Map<Integer, List<Adjacent<?, ?>>> weightedAdjMap = pFinder.getWeightedAdjMap();
		List<Adjacent<?, ?>> adjList = weightedAdjMap.get(start);
		Adjacent<?, ?> adj;
		float weight=0;
		for (Adjacent<?, ?> a : adjList) {
			if(a.getCity()==end) {
				weight=a.getWeight();
			}
		}
		return weight;
	}
	
	public float getHeuristic() {
		return heuristc;
	}
	private void setHeuristic() {
		setCost();
		float h=this.cost;
		//TODO add heuristic of last node
		this.heuristc = h;
	}

	public List<Integer> getPath() {
		return path;
	}

	/**
	 * @param path
	 * @return if the path is valid, meaning are all edges taken existing
	 */
	public boolean isPathValid(List<?> path) {
		return true;
	} // public boolean isPathValid(List<?> path)

}
